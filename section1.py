# -*- coding: utf-8 -*-
"""Student_PneumoniaDetection_Section1.ipynb - Jay Raval

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1K3PrtHC4fCxljoTUY3aU3JOfQk_TTkpP

![](https://storage.googleapis.com/kaggle-competitions/kaggle/10338/logos/header.png)
"""

import os
import numpy as np
import pandas as pd

import seaborn as sns
import matplotlib.pyplot as plt

from sklearn.linear_model import LogisticRegression
from sklearn.neural_network import MLPClassifier
from sklearn.neighbors import KNeighborsClassifier
from sklearn.tree import DecisionTreeClassifier
from sklearn.metrics import accuracy_score

class pkg:
  def get_metadata(metadata_path, which_splits = ['train', 'test']):
    '''returns metadata dataframe which contains columns of:
       * index: index of data into numpy data
       * class: class of image
       * split: which dataset split is this a part of?
    '''
    metadata = pd.read_csv(metadata_path)
    keep_idx = metadata['split'].isin(which_splits)
    return metadata[keep_idx]

  def get_data_split(split_name, flatten, all_data, metadata, image_shape):
    '''
    returns images (data), labels from folder of format [image_folder]/[split_name]/[class_name]/
    flattens if flatten option is True
    '''
    sub_df = metadata[metadata['split'].isin([split_name])]
    index  = sub_df['index'].values
    labels = sub_df['class'].values
    data = all_data[index,:]
    if flatten:
      data = data.reshape([-1, np.product(image_shape)])
    return data, labels

  def get_train_data(flatten, all_data, metadata, image_shape):
    return get_data_split('train', flatten, all_data, metadata, image_shape)

  def get_test_data(flatten, all_data, metadata, image_shape):
    return get_data_split('test', flatten, all_data, metadata, image_shape)

class helpers:
  #### PLOTTING
  def plot_one_image(data, labels = [], index = None, image_shape = [64,64,3]):
    '''
    if data is a single image, display that image

    if data is a 4d stack of images, display that image
    '''
    num_dims   = len(data.shape)
    num_labels = len(labels)

    # reshape data if necessary
    if num_dims == 1:
      data = data.reshape(target_shape)
    if num_dims == 2:
      data = data.reshape(np.vstack[-1, image_shape])
    num_dims   = len(data.shape)

    # check if single or multiple images
    if num_dims == 3:
      if num_labels > 1:
        print('Multiple labels does not make sense for single image.')
        return

      label = labels
      if num_labels == 0:
        label = ''
      image = data

    if num_dims == 4:
      image = data[index, :]
      label = labels[index]

    # plot image of interest
    print('Label: %s'%label)
    plt.imshow(image)
    plt.show()

  def plot_acc(history, ax = None, xlabel = 'Epoch #'):
    # i'm sorry for this function's code. i am so sorry.
    history = history.history
    history.update({'epoch':list(range(len(history['val_accuracy'])))})
    history = pd.DataFrame.from_dict(history)

    best_epoch = history.sort_values(by = 'val_accuracy', ascending = False).iloc[0]['epoch']

    if not ax:
      f, ax = plt.subplots(1,1)
    sns.lineplot(x = 'epoch', y = 'val_accuracy', data = history, label = 'Validation', ax = ax)
    sns.lineplot(x = 'epoch', y = 'accuracy', data = history, label = 'Training', ax = ax)
    ax.axhline(0.5, linestyle = '--',color='red', label = 'Chance')
    ax.axvline(x = best_epoch, linestyle = '--', color = 'green', label = 'Best Epoch')
    ax.legend(loc = 1)
    ax.set_ylim([0.4, 1])

    ax.set_xlabel(xlabel)
    ax.set_ylabel('Accuracy (Fraction)')

    plt.show()

### defining project variables
# file variables
metadata_url         = "https://storage.googleapis.com/inspirit-ai-data-bucket-1/Data/AI%20Scholars/Sessions%206%20-%2010%20(Projects)/Project%20-%20(Healthcare%20A)%20Pneumonia/metadata.csv"
image_data_url       = 'https://storage.googleapis.com/inspirit-ai-data-bucket-1/Data/AI%20Scholars/Sessions%206%20-%2010%20(Projects)/Project%20-%20(Healthcare%20A)%20Pneumonia/image_data.npy'
image_data_path      = './image_data.npy'
metadata_path        = './metadata.csv'
image_shape          = (64, 64, 3)

# neural net parameters
nn_params = {}
nn_params['input_shape']       = image_shape
nn_params['output_neurons']    = 1
nn_params['loss']              = 'binary_crossentropy'
nn_params['output_activation'] = 'sigmoid'

### update links
!wget "https://storage.googleapis.com/inspirit-ai-data-bucket-1/Data/AI%20Scholars/Sessions%206%20-%2010%20(Projects)/Project%20-%20(Healthcare%20A)%20Pneumonia/metadata.csv"
!wget "https://storage.googleapis.com/inspirit-ai-data-bucket-1/Data/AI%20Scholars/Sessions%206%20-%2010%20(Projects)/Project%20-%20(Healthcare%20A)%20Pneumonia/image_data.npy"

### pre-loading all data of interest
_all_data = np.load('image_data.npy')
_metadata = pkg.get_metadata(metadata_path, ['train','test','field'])

### preparing definitions
# downloading and loading data
get_data_split = pkg.get_data_split
get_metadata    = lambda :                 pkg.get_metadata(metadata_path, ['train','test'])
get_train_data  = lambda flatten = False : pkg.get_train_data(flatten = flatten, all_data = _all_data, metadata = _metadata, image_shape = image_shape)
get_test_data   = lambda flatten = False : pkg.get_test_data(flatten = flatten, all_data = _all_data, metadata = _metadata, image_shape = image_shape)
get_field_data  = lambda flatten = False : pkg.get_field_data(flatten = flatten, all_data = _all_data, metadata = _metadata, image_shape = image_shape)

# plotting
plot_one_image = lambda data, labels = [], index = None: helpers.plot_one_image(data = data, labels = labels, index = index, image_shape = image_shape);

metadata = get_metadata()

class_column = "Choose an Answer" #@param ["Choose an Answer", "Training and Testing data", "Pneumonia or Healthy", "Location in data"]
split_column = "Choose an Answer" #@param ["Choose an Answer", "Training and Testing data", "Pneumonia or Healthy", "Location in data"]
index_column = "Choose an Answer" #@param ["Choose an Answer", "Training and Testing data", "Pneumonia or Healthy", "Location in data"]


if class_column == "Pneumonia or Healthy":
  print("Yes! Our metadata's class column contains pneumonia xrays and healthy ones.")
else:
  print("Try again for the class column!")

if split_column == "Training and Testing data":
  print("Yes! Our metadata has already been split into the train and test data.")
else:
  print("Try again for the split column!")

if index_column == "Location in data":
  print("Yes! An xray's index will tell us where it is in our metadata.")
else:
  print("Try again for the index column!")


class_1 = "Choose an Answer" #@param ["Choose an Answer", "Healthy", "Pneumonia", "Benign", "Malignant"]

class_0 = "Choose an Answer" #@param ["Choose an Answer", "Healthy", "Pneumonia", "Benign", "Malignant"]

rows = "Choose an Answer" #@param ["Choose an Answer", "Number of Features", "Number of Images Total"]

if class_1 == "Pneumonia":
  print("Yes! Pneumonia is encoded as 1 in the class column.")
elif class_1 == "Healthy":
  print("A class of 1 is not healthy. Try again!")
else:
  print("Try again! Note that there aren't any cancer xrays in our metadata.")

if class_0 == "Healthy":
  print("Yes! Healthy is encoded as 0 in the class column.")
elif class_1 == "Pneumonia":
  print("A class of 1 is not pneumonia. Try again!")
else:
  print("Try again! Note that there aren't any cancer xrays in our metadata.")

if rows == "Number of Images Total":
  print("Yes! We have 2400 images in our dataset.")
else:
  print("Try again for the meaning of the 2400 rows!")

import seaborn as sns

metadata.groupby(['class']).count()
sns.countplot(x = 'class', data = metadata)

metadata.groupby(['split']).count()
sns.countplot(x = 'split', data = metadata)

train_data, train_labels = get_train_data()

print(train_data.shape)
print(train_labels.shape)

image = train_data[0]
image_label = train_labels[0]

print('Our image is stored as %s in Python'%type(image))
print('Our image has dimensions of (%d, %d, %d)'%image.shape)
print('Our image has label %d'%image_label)

Dimension_0  = "image height" #@param ["Your answer", "image width", "image height","number of colors"]

Dimension_1  = "image width" #@param ["Your answer", "image width", "image height","number of colors"]

Dimension_2  = "number of colors" #@param ["Your answer", "image width", "image height","number of colors"]

if Dimension_0 == 'image height':
  print("Yes! Dimension_0 is the height of the image.")
else:
  print("Try again for Dimension_0!")

if Dimension_1 == 'image width':
  print("Yes! Dimension_1 is the width of the image.")
else:
  print("Try again for Dimension_1!")

if Dimension_2 == 'number of colors':
  print("Yes! Dimension_2 stands for 3 colors - (r,g,b).")
else:
  print("Try again for Dimension_2!")


plot_one_image(image)
plot_one_image(train_data, train_labels, 7)

for i in range(4):
  plot_one_image(train_data, train_labels, i)

count = 0
i = 0
while count < 20:
  if train_labels[i] == 1.0:
    plot_one_image(train_data, train_labels, i)
    count = count+1
  i = i+1

import numpy as np

tiny_image = np.array([[[1, 0, 0],
                       [.5, .5, 0]],
                      [[0, 1, 1],
                       [.1, .2, 1]]])
print (tiny_image)
print ("Dimensions: ", tiny_image.shape)

plot_one_image(tiny_image)

tiny_image[:,:,2]

new_image = tiny_image.copy()
new_image[:,:,2] = 0

plot_one_image(new_image)

rect_image = image.copy()
plot_one_image(rect_image)

rect_image[5,5]
inputs = "Your answer" #@param ["Your answer","pneumonia vs. normal", "images", "image edges", "probability of pneumonia vs. normal"]

outputs = "Your answer" #@param ["Your answer","pneumonia vs. normal", "images", "image edges", "probability of pneumonia vs. normal"]

problem_type  = "Your answer" #@param ["Your answer", "classification", "regression"]


if inputs == "images":
  print("Yes, our inputs are our images!")
else:
  print('Not quite our inputs.')

if outputs == "pneumonia vs. normal":
  print("Yes, our outputs are pneumonia vs. normal!")
else:
  print('Not quite our outputs.')

if problem_type == "classification":
  print("We are trying to predict labels, therefore this is classification!")
else:
  print('Not quite our problem!')

(train_data, train_labels) = get_train_data(flatten = True)


"""###Creating Baseline Models

* knn = KNeighborsClassifier(n_neighbors = 5)`
* log = LogisticRegression(max_iter = 1000)`
* dt = DecisionTreeClassifier(max_depth = 2)`
* (https://scikit-learn.org/stable/auto_examples/classification/plot_classifier_comparison.html) (try MLPClassifier!)
"""